<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Design Paradigms - Interactive Handout V2</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root { --primary: #2c3e50; --accent: #e67e22; --bg: #f4f7f6; --error: #c0392b; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg); color: var(--primary); padding: 20px; line-height: 1.6; }
        .container { max-width: 1100px; margin: auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        h1, h2 { border-bottom: 2px solid var(--accent); padding-bottom: 10px; }
        section { margin-bottom: 50px; padding: 20px; border: 1px solid #ddd; border-radius: 8px; background: #fafafa; }
        
        .controls { background: #eee; padding: 10px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid var(--accent); }
        .controls label { margin-right: 10px; font-weight: bold; }
        select, input { padding: 5px; border-radius: 4px; border: 1px solid #ccc; }
        button { background: var(--primary); color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; transition: 0.2s; }
        button:hover { background: var(--accent); }
        button.reset { background: #7f8c8d; }

        .flow { display: flex; align-items: center; justify-content: start; margin: 20px 0; flex-wrap: nowrap; overflow-x: auto; padding-bottom: 10px;}
        .box { padding: 15px; border: 2px solid var(--primary); border-radius: 8px; text-align: center; min-width: 120px; background: #fff; margin: 0 10px; flex-shrink: 0;}
        .arrow { font-size: 24px; font-weight: bold; color: var(--accent);flex-shrink: 0; }

        /* Common Bits */
        .bit-group { display: flex; gap: 2px; justify-content: center; flex-wrap: wrap; max-width: 180px; margin: auto; }
        .bit { width: 35px; height: 35px; border: 1px solid #333; line-height: 35px; cursor: pointer; user-select: none; transition: 0.3s; text-align: center; font-weight: bold;}
        .bit.flipped { background: var(--error); color: white; border-color: #a93226; }
        .bit.parity { border-style: dashed; background: #ecf0f1; color: #555; }
        
        /* Grid Parity */
        .grid-container { display: grid; grid-template-columns: repeat(5, 40px); gap: 4px; justify-content: center; }
        
        /* Hamming Specific */
        .hamming-box { border: 1px solid #ccc; padding: 4px; margin: 2px; display: inline-block; text-align: center; width: 55px; cursor: pointer; background: #fff;}
        .hamming-box.parity-pos { background: #f0f3f4; border-style: dashed; }
        .hamming-val { font-size: 1.3em; font-weight: 800; }
        .hamming-idx { font-size: 0.7em; color: #7f8c8d; }
        .hamming-bin { font-size: 0.65em; font-family: monospace; color: var(--accent); }

        /* RS Styles */
        #rs-status { font-weight: bold; }
    </style>
</head>
<body>

<div class="container">
    <h1>Interactive Algorithm Visuals</h1>

    <section>
        <h2>1. Triple Copy Encoding (Majority Rule)</h2>
        <div class="controls">
            <label>Input Message Bit:</label>
            <select id="tc-input" onchange="encodeTC()">
                <option value="0">0</option>
                <option value="1" selected>1</option>
            </select>
            <button onclick="encodeTC()">Re-Encode</button>
        </div>
        <div class="flow">
            <div class="box"><strong>Message</strong><br><span id="tc-msg-disp">1</span></div>
            <div class="arrow">→</div>
            <div class="box" style="background:#eef;"><strong>Encoded Channel</strong><br>(Click to flip bits)<br>
                <div id="tc-bits" class="bit-group" style="margin-top:10px;"></div>
            </div>
            <div class="arrow">→</div>
            <div class="box"><strong>Decoded Message</strong><br><span id="tc-decoded" style="font-size: 1.5em; font-weight:bold;">1</span></div>
        </div>
    </section>

    <section>
    <h2>2. 2D Grid Parity (Encoding vs Channel)</h2>

    <div class="controls">
        <p style="font-size:0.9em">
            1️⃣ Set data bits in the <b>Encoding Grid</b><br>
            2️⃣ Parity is automatically added<br>
            3️⃣ Click bits in the <b>Channel Grid</b> to add errors
        </p>
        <button class="reset" onclick="reset2DParity()">Reset</button>
    </div>

    <div class="flow">

        <div class="box" style="min-width:260px">
            <strong>Encoder Grid</strong><br>
            <small>(Set data bits only)</small><br><br>
            <div id="encoder-grid" class="grid-container"></div>
        </div>

        <div class="arrow">→</div>

        <div class="box" style="min-width:260px">
            <strong>Channel Grid</strong><br>
            <small>(Click any bit to add error)</small><br><br>
            <div id="channel-grid" class="grid-container"></div>
        </div>

        <div class="arrow">→</div>

        <div class="box">
            <strong>Receiver</strong><br>
            <span id="receiver-status" style="font-weight:bold">Valid</span>
        </div>

    </div>
</section>


    <section>
        <h2>3. Hamming Code (7, 4)</h2>
        <div class="controls">
            <label>Input 4 Data Bits (D1-D4):</label>
            <select id="ham-d1"><option>0</option><option selected>1</option></select>
            <select id="ham-d2"><option selected>0</option><option>1</option></select>
            <select id="ham-d3"><option>0</option><option selected>1</option></select>
            <select id="ham-d4"><option>0</option><option selected>1</option></select>
            <button onclick="encodeHamming()">Encode Message</button>
            <span style="font-size:0.8em; margin-left: 10px;">(Data goes into pos 3,5,6,7. Parity calc'd for 1,2,4)</span>
        </div>
        <div class="flow">
            <div class="box" style="background:#eef; min-width: 500px;"><strong>Transmitted Code word</strong><br>(Click any box to flip bit)<br>
                 <div id="hamming-container" style="display: flex; justify-content: center; margin-top: 15px;"></div>
            </div>
            <div class="arrow">→</div>
            <div class="box"><strong>Decoder Result</strong><br><span id="hamming-error-pos" style="color: var(--error); font-weight:bold;">None</span></div>
        </div>
    </section>

    <section>
        <h2>4. Reed-Solomon (Polynomial Interpolation)</h2>
        <div class="controls">
            N (Points Needed): <input type="number" id="rs-n" value="3" min="2" max="5" style="width:50px">
            K (Extra Points): <input type="number" id="rs-k" value="3" min="1" max="5" style="width:50px">
            Message Values (csv): <input type="text" id="rs-vals" value="3, 8, 2" style="width: 120px;">
            <button onclick="initRS()">Encode & Send</button>
        </div>
        <p><em>Click blue bars to "erase" them in transit. If too many are lost, grey lines show alternate possibilities, proving irrecoverability.</em></p>
        <div style="background: white; padding: 10px;">
             <canvas id="rsChart" height="180"></canvas>
        </div>
        <div class="flow" style="justify-content: center;">
            <div class="box" style="min-width: 300px;"><strong>Decoder Status:</strong> <span id="rs-status"></span></div>
        </div>
    </section>
</div>

<script>
    // --- TRIPLE COPY LOGIC ---
    let tcBits = [1, 1, 1]; // The bits in the channel

    function encodeTC() {
        const msgBit = parseInt(document.getElementById('tc-input').value);
        document.getElementById('tc-msg-disp').innerText = msgBit;
        // Reset channel bits to the encoded message
        tcBits = [msgBit, msgBit, msgBit];
        renderTC();
    }

    function renderTC() {
        const container = document.getElementById('tc-bits');
        container.innerHTML = '';
        tcBits.forEach((b, i) => {
            let el = document.createElement('div');
            // Visual trick: if bit doesn't match majority, it looks 'flipped'
            const sum = tcBits.reduce((a,b) => a+b, 0);
            const majority = sum >= 2 ? 1 : 0;
            el.className = 'bit' + (b !== majority ? ' flipped' : '');
            el.innerText = b;
            // Click to simulate error in channel
            el.onclick = () => { tcBits[i] = 1 - tcBits[i]; renderTC(); };
            container.appendChild(el);
        });
        const sum = tcBits.reduce((a,b) => a+b, 0);
        const decoded = sum >= 2 ? 1 : 0;
        document.getElementById('tc-decoded').innerText = decoded;
        document.getElementById('tc-decoded').style.color = (sum === 0 || sum === 3) ? 'green' : '#e67e22'; // Orange if correcting
    }

    // --- GRID PARITY LOGIC ---
    // gridData holds the current state of all 25 bits (16 data + 9 parity)
    let encoderGrid = Array(25).fill(0);
let channelGrid = Array(25).fill(0);

function reset2DParity() {
    encoderGrid.fill(0);
    channelGrid.fill(0);
    renderEncoderGrid();
    renderChannelGrid();
}

function calculateParity(grid) {
    for (let r = 0; r < 4; r++) {
        let sum = 0;
        for (let c = 0; c < 4; c++) sum += grid[r * 5 + c];
        grid[r * 5 + 4] = sum % 2;
    }

    for (let c = 0; c < 5; c++) {
        let sum = 0;
        for (let r = 0; r < 4; r++) sum += grid[r * 5 + c];
        grid[20 + c] = sum % 2;
    }
}

function renderEncoderGrid() {
    calculateParity(encoderGrid);
    const el = document.getElementById("encoder-grid");
    el.innerHTML = "";

    for (let i = 0; i < 25; i++) {
        const r = Math.floor(i / 5), c = i % 5;
        const bit = document.createElement("div");
        bit.className = "bit";
        bit.innerText = encoderGrid[i];

        if (r >= 4 || c >= 4) {
            bit.classList.add("parity");
        } else {
            bit.onclick = () => {
                encoderGrid[i] ^= 1;
                renderEncoderGrid();
                channelGrid = [...encoderGrid];
                renderChannelGrid();
            };
        }
        el.appendChild(bit);
    }
}

function renderChannelGrid() {
    const el = document.getElementById("channel-grid");
    el.innerHTML = "";

    for (let i = 0; i < 25; i++) {
        const bit = document.createElement("div");
        bit.className = "bit";
        bit.innerText = channelGrid[i];
        bit.onclick = () => {
            channelGrid[i] ^= 1;
            renderChannelGrid();
            checkReceiver();
        };
        el.appendChild(bit);
    }
    checkReceiver();
}

function checkReceiver() {
    let rowErr = [], colErr = [];

    for (let r = 0; r < 5; r++) {
        let sum = 0;
        for (let c = 0; c < 5; c++) sum += channelGrid[r * 5 + c];
        if (sum % 2 !== 0) rowErr.push(r);
    }

    for (let c = 0; c < 5; c++) {
        let sum = 0;
        for (let r = 0; r < 5; r++) sum += channelGrid[r * 5 + c];
        if (sum % 2 !== 0) colErr.push(c);
    }

    const status = document.getElementById("receiver-status");

    if (rowErr.length === 0 && colErr.length === 0) {
        status.innerText = "Valid (No Error)";
        status.style.color = "green";
    } else if (rowErr.length === 1 && colErr.length === 1) {
        status.innerText = `Single-bit error at Row ${rowErr[0] + 1}, Col ${colErr[0] + 1}`;
        status.style.color = "orange";
    } else {
        status.innerText = "Multiple Errors Detected";
        status.style.color = "red";
    }
}



    // --- HAMMING LOGIC (7,4) ---
    // hamBits stores the actual 7 bits currently in the channel (indices 0-6)
    let hamBits = Array(7).fill(0); 

    function encodeHamming() {
        const d1 = parseInt(document.getElementById('ham-d1').value);
        const d2 = parseInt(document.getElementById('ham-d2').value);
        const d3 = parseInt(document.getElementById('ham-d3').value);
        const d4 = parseInt(document.getElementById('ham-d4').value);

        // Place data bits in positions 3, 5, 6, 7 (indices 2, 4, 5, 6)
        hamBits[2] = d1; hamBits[4] = d2; hamBits[5] = d3; hamBits[6] = d4;

        // Calculate parity for positions 1, 2, 4 (indices 0, 1, 3)
        // P1 (pos 1) checks 1,3,5,7 (idx 0,2,4,6)
        hamBits[0] = (hamBits[2] + hamBits[4] + hamBits[6]) % 2; 
        // P2 (pos 2) checks 2,3,6,7 (idx 1,2,5,6)
        hamBits[1] = (hamBits[2] + hamBits[5] + hamBits[6]) % 2;
        // P4 (pos 4) checks 4,5,6,7 (idx 3,4,5,6)
        hamBits[3] = (hamBits[4] + hamBits[5] + hamBits[6]) % 2;

        renderHamming();
    }

    function renderHamming() {
        const container = document.getElementById('hamming-container');
        container.innerHTML = '';
        
        // Decoder Logic: Calculate syndrome
        let p1 = (hamBits[0]+hamBits[2]+hamBits[4]+hamBits[6]) % 2;
        let p2 = (hamBits[1]+hamBits[2]+hamBits[5]+hamBits[6]) % 2;
        let p4 = (hamBits[3]+hamBits[4]+hamBits[5]+hamBits[6]) % 2;
        let errorPosStr = "" + p4 + p2 + p1; // Binary string e.g., "101"
        let errorIdx = parseInt(errorPosStr, 2) - 1; // Convert to index (-1 because pos is 1-based)

        hamBits.forEach((v, idx) => {
            let pos = idx + 1;
            let box = document.createElement('div');
            box.className = 'hamming-box';
            // Highlight parity positions visually
            if ([1,2,4].includes(pos)) box.className += ' parity-pos';
            // Highlight detected error visually
            if (idx === errorIdx) box.style.backgroundColor = "#fdd";

            box.innerHTML = `<div class="hamming-idx">${pos}</div>
                             <div class="hamming-val">${v}</div>
                             <div class="hamming-bin">${pos.toString(2).padStart(3, '0')}</div>`;
            // Click to simulate channel error
            box.onclick = () => { hamBits[idx] = 1 - hamBits[idx]; renderHamming(); };
            container.appendChild(box);
        });
        
        const status = document.getElementById('hamming-error-pos');
        if (errorIdx < 0) {
            status.innerText = "Clean / Corrected"; status.style.color = "green";
        } else {
             status.innerText = `Error detected at Position ${errorIdx + 1} (Binary ${errorPosStr})`; status.style.color = "var(--error)";
        }
    }


    // --- REED SOLOMON LOGIC ---
    let rsChart;
    let rsErasureMask = []; // true if erased at index
    let rsOriginalPolyPoints = [];
    let rsLabels = [];

    // Basic Lagrange Interpolation (Real numbers for visualization)
    function lagrangeInterpolate(pointsX, pointsY, targetX) {
        let total = 0;
        let n = pointsX.length;
        for (let i = 0; i < n; i++) {
            let term = pointsY[i];
            for (let j = 0; j < n; j++) {
                if (i !== j) term *= (targetX - pointsX[j]) / (pointsX[i] - pointsX[j]);
            }
            total += term;
        }
        return total;
    }

    function initRS() {
        const N = parseInt(document.getElementById('rs-n').value);
        const K = parseInt(document.getElementById('rs-k').value);
        const msgStr = document.getElementById('rs-vals').value;
        let msgVals = msgStr.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));

        // Padding or truncating message to length N
        if(msgVals.length < N) {
             while(msgVals.length < N) msgVals.push(0); // Pad with zeros
        } else if (msgVals.length > N) {
             msgVals = msgVals.slice(0, N);
        }
        document.getElementById('rs-vals').value = msgVals.join(', ');

        rsErasureMask = Array(N+K).fill(false);
        rsLabels = Array.from({length: N+K}, (_, i) => i + 1);

        // Create the original polynomial based on message values acting as first N points
        const msgXs = Array.from({length: N}, (_, i) => i + 1);
        
        // Generate all N+K points that will be transmitted
        rsOriginalPolyPoints = rsLabels.map(x => lagrangeInterpolate(msgXs, msgVals, x));

        drawRSChart(N, K);
        updateRSStatus(N, K);
    }

    function drawRSChart(N, K) {
        const ctx = document.getElementById('rsChart').getContext('2d');
        
        // Generate smooth curve data for the original poly
        const curveX = Array.from({length: 100}, (_, i) => 0.5 + i * (N+K)/100);
        // We need the original N points to generate the curve
        const origNx = rsLabels.slice(0,N);
        const origNy = rsOriginalPolyPoints.slice(0,N);
        const curveY = curveX.map(x => lagrangeInterpolate(origNx, origNy, x));

        const mainDataset = {
            type: 'bar',
            label: 'Transmitted Values (Click to Erase)',
            data: rsOriginalPolyPoints,
            backgroundColor: rsLabels.map((_, i) => rsErasureMask[i] ? '#e0e0e0' : 'rgba(52, 152, 219, 0.8)'),
            borderColor: rsLabels.map((_, i) => rsErasureMask[i] ? '#ccc' : '#2980b9'),
            borderWidth: 1,
            order: 2
        };

        const originalLineDataset = {
             type: 'line',
             label: 'Original Polynomial Curve',
             data: curveX.map((x, i) => ({x: x, y: curveY[i]})),
             borderColor: '#e67e22', borderDash: [], pointRadius: 0, borderWidth: 3, fill: false, order: 1
        };

        let chartData = { labels: rsLabels, datasets: [mainDataset, originalLineDataset] };

        if(rsChart) rsChart.destroy();
        rsChart = new Chart(ctx, {
            data: chartData,
            options: {
                responsive: true, maintainAspectRatio: false,
                onClick: (e, items) => {
                    if(items.length > 0) {
                        const idx = items[0].index;
                        // Only allow clicking bars (dataset 0)
                        if(items[0].datasetIndex === 0) {
                            rsErasureMask[idx] = !rsErasureMask[idx];
                            // Update visual appearance of bars immediately
                            rsChart.data.datasets[0].backgroundColor = rsLabels.map((_, i) => rsErasureMask[i] ? '#e0e0e0' : 'rgba(52, 152, 219, 0.8)');
                            rsChart.update('none'); // update without animation
                            updateRSStatus(N, K); // calculate status and potentially add ghost lines
                        }
                    }
                },
                scales: { 
                    x: { type: 'linear', position: 'bottom', min: 0.5, max: N+K+0.5, grid: {display:false} },
                    y: { beginAtZero: true }
                 },
                plugins: { legend: { display: false } }
            }
        });
    }

    function updateRSStatus(N, K) {
        let remainingX = [];
        let remainingY = [];
        let erasedX = [];

        rsErasureMask.forEach((erased, idx) => {
            if(!erased) {
                remainingX.push(rsLabels[idx]);
                remainingY.push(rsOriginalPolyPoints[idx]);
            } else {
                erasedX.push(rsLabels[idx]);
            }
        });

        const remainingCount = remainingX.length;
        const statusEl = document.getElementById('rs-status');

        // Remove old "alternative" lines first (keep first 2 datasets: bars and original line)
        rsChart.data.datasets = rsChart.data.datasets.slice(0, 2);

        if (remainingCount >= N) {
            statusEl.innerHTML = `<span style="color:green">RECOVERABLE</span> (${remainingCount}/${N} needed points available). The original curve is unique.`;
            rsChart.data.datasets[1].borderColor = '#e67e22'; // Solid orange line
        } else {
            statusEl.innerHTML = `<span style="color:var(--error)">IRRECOVERABLE</span> (Only ${remainingCount}/${N} points left). Cannot uniquely determine the curve. Showing alternative possibilities below.`;
            
            // MAKE ORIGINAL LINE GREY/DASHED
            rsChart.data.datasets[1].borderColor = '#bdc3c7'; 
            rsChart.data.datasets[1].borderDash = [5, 5];

            // GENERATE ALTERNATIVE POLYNOMIALS
            const needed = N - remainingCount;
            // We need at least 1 erased point to generate alternatives.
            if(erasedX.length >= needed && needed > 0) {
                 // Generate 3 alternative possibilities
                 for(let k=0; k<3; k++) {
                     let altXs = [...remainingX];
                     let altYs = [...remainingY];
                     
                     // Pick 'needed' erased spots and assign RANDOM Y values
                     // Shuffle erasedX to pick randomly if there are many erased spots
                     let shuffledErased = [...erasedX].sort(() => 0.5 - Math.random());
                     
                     for(let i=0; i<needed; i++) {
                         altXs.push(shuffledErased[i]);
                         // Generate a random Y roughly within the range of existing data to look plausible
                         let maxY = Math.max(...rsOriginalPolyPoints, 10);
                         altYs.push(Math.random() * maxY * 1.2);
                     }

                     // Generate curve points for this new set of N points
                     const curveX = Array.from({length: 50}, (_, i) => 0.5 + i * (N+K)/50);
                     const curveY = curveX.map(x => lagrangeInterpolate(altXs, altYs, x));

                     rsChart.data.datasets.push({
                         type: 'line', label: `Alternate Possibility ${k+1}`,
                         data: curveX.map((x, i) => ({x: x, y: curveY[i]})),
                         borderColor: '#95a5a6', borderDash: [2, 2], pointRadius: 0, borderWidth: 1, fill: false
                     });
                 }
            }
        }
        rsChart.update();
    }

    // Init all on load
    encodeTC();
    resetGridMessage();
    encodeHamming();
    initRS();
</script>

</body>
</html>